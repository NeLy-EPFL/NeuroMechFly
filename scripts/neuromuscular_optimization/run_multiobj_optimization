#!/usr/bin/env python
""" Script to run NSGA-II multip objective optimization. """

from datetime import datetime
import os
from pathlib import Path
import pkgutil
import farms_pylog as pylog
from jmetal.algorithm.multiobjective.nsgaii import NSGAII
from jmetal.lab.visualization import Plot
from jmetal.operator import PolynomialMutation, SBXCrossover
from jmetal.util.evaluator import MultiprocessEvaluator
from jmetal.util.observer import ProgressBarObserver, VisualizerObserver
from jmetal.util.ranking import FastNonDominatedRanking
from jmetal.util.solution import (print_function_values_to_file,
                                  print_variables_to_file)
from jmetal.util.termination_criterion import StoppingByEvaluations

from NeuroMechFly.experiments.network_optimization import multiobj_optimization
from NeuroMechFly.experiments.network_optimization.multiobj_optimization import \
    WriteFullFrontToFileObserver, separate_penalties_into_gens

neuromechfly_path = Path(pkgutil.get_loader("NeuroMechFly").get_filename()).parents[1]


if __name__ == "__main__":
    """ Main """
    n_pop = 20
    n_gen = 50
    max_evaluations = n_pop*n_gen
    # Problem
    problem = multiobj_optimization.DrosophilaEvolution()
    max_evaluations = n_pop*n_gen

    # Algorithm
    algorithm = NSGAII(
        problem=problem,
        population_size=n_pop,
        offspring_population_size=n_pop,
        mutation=PolynomialMutation(
            probability=1.0 / problem.number_of_variables,
            distribution_index=0.20,
        ),
        crossover=SBXCrossover(
            probability=1.0,
            distribution_index=20,
        ),
        population_evaluator=MultiprocessEvaluator(8),
        termination_criterion=StoppingByEvaluations(
            max_evaluations=max_evaluations
        ),
        # dominance_comparator=DominanceComparator()
    )
    # Output directory
    output_dir = os.path.join(
        neuromechfly_path,
        'scripts/neuromuscular_optimization'
    )
    # Results Dumping
    result_path = 'optimization_results/run_{}_var_{}_obj_{}_pop_{}_gen_{}_{}'.format(
            problem.get_name(),
            problem.number_of_variables,
            problem.number_of_objectives,
            n_pop,
            n_gen,
            datetime.now().strftime('%y%m%d_%H%M%S'),
    )
    algorithm.observable.register(
        observer=WriteFullFrontToFileObserver(
            output_directory=(
                os.path.join(output_dir, result_path)
            )
        )
    )

    # Visualisers
    algorithm.observable.register(
        observer=ProgressBarObserver(max=max_evaluations)
    )
    algorithm.observable.register(
        observer=VisualizerObserver(
            reference_front=problem.reference_front
        )
    )

    # Run optimisation
    algorithm.run()

    # Get results
    front = algorithm.get_result()
    ranking = FastNonDominatedRanking()
    # pareto_fronts = ranking.compute_ranking(front)

    # Plot front
    plot_front = Plot(
        title='Pareto front approximation',
        reference_front=problem.reference_front,
        axis_labels=problem.obj_labels)
    plot_front.plot(front, filename=algorithm.get_name())

    # Save results of the latest generation to a .txt file
    print_function_values_to_file(front,  os.path.join(output_dir,'FUN.txt'))
    print_variables_to_file(front,  os.path.join(output_dir,'VAR.txt'))

    # Save penalties into separate files
    separate_penalties_into_gens(n_gen, n_pop, os.path.join(output_dir, result_path))

    print('Algorithm (continuous problem): ' + algorithm.get_name())
    print('Problem: ' + problem.get_name())
    print('Computing time: ' + str(algorithm.total_computing_time*1/60))
