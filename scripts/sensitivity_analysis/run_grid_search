#!/usr/bin/env python
""" Perform sensitivity analysis """

import os
from pathlib import Path
import pkgutil
import glob
from datetime import datetime
import numpy as np
import pandas as pd
import pickle
from multiprocessing import Pool

from NeuroMechFly.experiments.kinematic_replay import kinematic_replay
from farms_container import Container

neuromechfly_path = Path(pkgutil.get_loader(
    "NeuroMechFly").get_filename()).parents[1]


def load_data(path):
    """ Loads the simulation data from h5 files into a dictionary.

    Returns
    -------
    [dict]
        Dictionary contains the physics data of each simulation run.

    Raises
    ------
    FileNotFoundError
        When directory does not exist.
    """

    file_names = [
        'joint_positions',
        'joint_velocities',
        'joint_torques',
        'contact_normal_force',
        'contact_lateral_force',
        'ball_rotations'
    ]

    pybullet_data = {key: dict() for key in file_names}

    if not os.path.exists(path):
        raise FileNotFoundError(f"{path} is not a valid path")

    for folder_name in os.listdir(path):
        if folder_name.startswith('.'):
            continue
        for physics_file_name in file_names:
            print(f"Loading {physics_file_name} in {folder_name}...")
            dir_name = os.path.join(
                path,
                folder_name,
                'physics',
                physics_file_name + '.h5',
            )
            pybullet_data[physics_file_name][folder_name] = pd.read_hdf(
                dir_name)

    return pybullet_data


def run_simulation(kp, kv):
    """ Run simulation with given kp and kv values. """
    run_time = 6.0
    time_step = 5e-4
    starting_time = 0.5
    behavior = 'walking'

    #: Setting up the collision and ground sensors
    side = ['L', 'R']
    pos = ['F', 'M', 'H']
    leg_segments = ['Tibia'] + ['Tarsus' + str(i) for i in range(1, 6)]
    left_front_leg = ['LF' + name for name in leg_segments]
    right_front_leg = ['RF' + name for name in leg_segments]
    body_segments = [s + b for s in side for b in ['Eye', 'Antenna']]

    self_collision = []
    for link0 in left_front_leg:
        for link1 in right_front_leg:
            self_collision.append([link0, link1])

    for link0 in left_front_leg + right_front_leg:
        for link1 in body_segments:
            if link0[0] == link1[0]:
                self_collision.append([link0, link1])

    ground_contact = [
        s +
        p +
        name for s in side for p in pos for name in leg_segments if name != 'Tibia']

    #: Setting the fixed joint angles to default values, can be altered to change the appearance of the fly
    fixed_positions = {
        'revolute_support_1': 3.6,
        'joint_A3': -15,
        'joint_A4': -15,
        'joint_A5': -15,
        'joint_A6': -15,
        'joint_LAntenna': 35,
        'joint_RAntenna': -35,
        'joint_Rostrum': 90,
        'joint_Haustellum': -60,
        'joint_LWing_roll': 90,
        'joint_LWing_yaw': -17,
        'joint_RWing_roll': -90,
        'joint_RWing_yaw': 17,
        'joint_Head': 10
    }

    #: Setting up the paths for the SDF and POSE files
    model_path = os.path.join(neuromechfly_path,
                              'data/design/sdf/neuromechfly_noLimits.sdf')
    pose_path = os.path.join(
        neuromechfly_path,
        'data/config/pose/pose_default.yaml')

    #: Paths of the position and velocity data
    joint_tracking_path = os.path.join(
        neuromechfly_path,
        f'data/joint_tracking/{behavior}/df3d')
    angles_path = glob.glob(joint_tracking_path + '/joint_angles*.pkl')[0]
    velocity_path = glob.glob(joint_tracking_path + '/joint_velocities*.pkl')[0]

    try:
        data_path = os.path.join(
            neuromechfly_path,
            'data/sensitivity_analysis/')
        os.makedirs(data_path)
        print('Directory does not exist, creating...')
    except FileExistsError:
        pass


    #: Simulation options
    sim_options = {
        "headless": True,
        "model": model_path,
        "pose": pose_path,
        "model_offset": [0., 0, 11.2e-3],
        "run_time": run_time,
        "base_link": 'Thorax',
        "ground_contacts": ground_contact,
        "self_collisions": self_collision,
        "draw_collisions": False,  # : Set True to change the color of colliding segments
        "record": False,  # : Set True to record the simulation
        'camera_distance': 5.5,
        'track': False,
        'moviename': './videos/kinematic_replay_video.mp4',
        'moviespeed': 0.2,  # : Speed of the recorded movie
        'slow_down': False,
        'sleep_time': 0.001,
        'rot_cam': False,  # : Set true to rotate the camera automatically
        'behavior': behavior,
        'ground': 'ball',
        'ball_mass': 54.6e-6,
        'ball_friction_coef': 1.3,
        'contactERP': 0.1,
        'globalCFM': 5.0,
        'numSolverIterations': 1000
    }

    #: Initialize the container
    container = Container(run_time / time_step)
    #: Initialize the simulation
    animal = kinematic_replay.DrosophilaSimulation(
        container,
        sim_options,
        fixed_positions=fixed_positions,
        kp=kp,
        kv=kv,
        angles_path=angles_path,
        velocity_path=velocity_path,
        starting_time=starting_time,
    )
    #: Run the simulation
    animal.run(optimization=False)
    #: Dump the results based on the date
    animal.container.dump(
        dump_path=os.path.join(
            data_path,
            'kp{}_kv{}'.format(
                round(kp, 1),
                round(kv, 1),
            )
        ),
        overwrite=False
    )


if __name__ == "__main__":

    #: Sweep across varying proportional and derivative gain values
    with Pool(processes=10) as pool:
        pool.starmap(
            run_simulation,
            [
                (proportional_gain, derivative_gain)
                for proportional_gain in np.arange(0.1, 1.1, 0.1)
                for derivative_gain in np.arange(0.1, 1.1, 0.1)
            ]
        )

    data_path = os.path.join(neuromechfly_path,'data/sensitivity_analysis/')
    #: Load data
    pybullet_data = load_data(data_path)
    #: Save data
    pickle.dump(
        pybullet_data,
        open(os.path.join(data_path,"sensitivity_analysis_data.pkl"),"wb")
    )
